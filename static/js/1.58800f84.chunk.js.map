{"version":3,"sources":["../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js","../node_modules/uuid/lib/rng-browser.js","../node_modules/uuid/lib/bytesToUuid.js","../node_modules/uuid/v1.js","../node_modules/uuid/v4.js","../node_modules/json-dry/lib/json-dry.js","../node_modules/uuid/index.js"],"names":["Parent","args","Class","Reflect","construct","sham","Proxy","Date","prototype","toString","call","e","isNativeReflectConstruct","a","push","apply","instance","Function","bind","setPrototypeOf","arguments","_cache","Map","undefined","fn","indexOf","TypeError","has","get","set","Wrapper","getPrototypeOf","this","constructor","Object","create","value","enumerable","writable","configurable","getRandomValues","crypto","msCrypto","window","rnds8","Uint8Array","module","exports","rnds","Array","r","i","Math","random","byteToHex","substr","buf","offset","bth","join","_nodeId","_clockseq","rng","bytesToUuid","_lastMSecs","_lastNSecs","options","b","node","clockseq","seedBytes","msecs","getTime","nsecs","dt","Error","tl","tmh","n","ii","special_char","safe_special_char","escaped_safe_special_char","special_char_rg","RegExp","safe_special_char_rg","get_regex","undriers","driers","createDryReplacer","root","replacer","value_paths","WeakMap","flags","is_root","chain","path","dryReplacer","holder","key","is_wrap","__is_wrap","__is_object","class_name","seen_path","new_value","replaced","is_array","last","temp","len","name","length","pop","replace","slice","fnc","dry","add_path","drypath","valueOf","isNaN","toISOString","toDry","namespace","dry_class","toJSON","isArray","String","keys","recurseGeneralObject","replaceObject","isFinite","findClass","ns","Classes","fromPath","main_class","getClassForUndry","console","log","regenerate","current","seen","retrieve","undry_paths","old","current_path","regenerateArray","undried","extra_pass","hasOwnProperty","retrieveFromPath","split","getFromOld","regenerateObject","pieces","result","obj","here","setPath","force","toDryObject","walk","stringify","space","JSON","toObject","parse","object","reviver","entry","exec","Infinity","unDry","unDryConstructor","unDryFunction","generateReviver","forEach","path_array","path_string","clone","custom_method","extra_args","wm","source","concat","real_clone","entry_type","name_type","target","dryClone","match","registerClass","context","registerUndrier","registerDrier","v1","v4","uuid"],"mappings":"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","file":"static/js/1.58800f84.chunk.js","sourcesContent":["import setPrototypeOf from \"./setPrototypeOf\";\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf\";\nimport setPrototypeOf from \"./setPrototypeOf\";\nimport isNativeFunction from \"./isNativeFunction\";\nimport construct from \"./construct\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto\n// implementation. Also, find the complete implementation of crypto on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nmodule.exports = bytesToUuid;","var rng = require('./lib/rng');\n\nvar bytesToUuid = require('./lib/bytesToUuid'); // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/broofa/node-uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;","var rng = require('./lib/rng');\n\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;","\"use strict\";\n\nvar special_char = '~',\n    safe_special_char = '\\\\x7e',\n    escaped_safe_special_char = '\\\\' + safe_special_char,\n    special_char_rg = RegExp(safe_special_char, 'g'),\n    safe_special_char_rg = RegExp(escaped_safe_special_char, 'g'),\n    get_regex = /^\\/(.*)\\/(.*)/,\n    undriers = {},\n    driers = {};\n/**\n * Generate a replacer function\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.0\n * @version  1.0.1\n *\n * @param    {Object}   root\n * @param    {Function} replacer\n *\n * @return   {Function}\n */\n\nfunction createDryReplacer(root, replacer) {\n  var value_paths = new WeakMap(),\n      seen_path,\n      flags = {\n    is_root: true\n  },\n      chain = [],\n      path = [],\n      temp,\n      last,\n      len;\n  return function dryReplacer(holder, key, value) {\n    // Process the value to a possible given replacer function\n    if (replacer != null) {\n      value = replacer.call(holder, key, value);\n    } // All falsy values can be returned as-is\n\n\n    if (!value) {\n      return value;\n    }\n\n    var is_wrap; // An explicitly false key means this dryReplaced was\n    // recursively called with a replacement object\n\n    if (key === false) {\n      key = '';\n      is_wrap = true; // Wrappers get added to the object chain, but not the path\n      // We need to be able to identify them later on\n\n      holder.__is_wrap = true; // See if the wrapped value is an object\n\n      if (holder[''] != null && typeof holder[''] === 'object') {\n        holder.__is_object = true;\n      }\n    }\n\n    switch (typeof value) {\n      case 'function':\n        // If no drier is created, return now.\n        // Else: fall through\n        if (!driers.Function) {\n          return;\n        }\n\n      case 'object':\n        value = replaceObject(dryReplacer, value, chain, flags, is_wrap, holder, path, value_paths, key);\n        break;\n\n      case 'string':\n        // Make sure regular strings don't start with the path delimiter\n        if (!flags.is_root && value[0] == '~') {\n          value = safe_special_char + value.slice(1);\n        }\n\n        break;\n\n      case 'number':\n        // Allow infinite values\n        if (value && !isFinite(value)) {\n          if (value > 0) {\n            value = {\n              dry: '+Infinity'\n            };\n          } else {\n            value = {\n              dry: '-Infinity'\n            };\n          }\n        }\n\n        break;\n    }\n\n    return value;\n  };\n}\n/**\n * Actually replace the object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.0\n * @version  1.0.11\n */\n\n\nfunction replaceObject(dryReplacer, value, chain, flags, is_wrap, holder, path, value_paths, key) {\n  var class_name, seen_path, new_value, replaced, is_array, keys, last, temp, len, i;\n\n  if (typeof value.constructor == 'function') {\n    class_name = value.constructor.name;\n  } else {\n    class_name = 'Object';\n  } // See if the chain needs popping\n\n\n  while (len = chain.length) {\n    // If the current object at the end of the chain does not\n    // match the current holder, move one up\n    // Don't mess with the chain if this is a wrap object\n    if (!is_wrap && holder !== chain[len - 1]) {\n      last = chain.pop(); // Only pop the path if the popped object isn't a wrapper\n\n      if (last && !last.__is_wrap) {\n        path.pop();\n      }\n    } else {\n      break;\n    }\n  } // Has the object been seen before?\n\n\n  seen_path = value_paths.get(value);\n\n  if (seen_path) {\n    // If the path is still an array,\n    // turn it into a string now\n    if (typeof seen_path != 'string') {\n      // First iterate over the pieces and escape them\n      for (i = 0; i < seen_path.length; i++) {\n        if (seen_path[i].indexOf(special_char) > -1) {\n          seen_path[i] = seen_path[i].replace(special_char_rg, safe_special_char);\n        }\n      }\n\n      seen_path = special_char + seen_path.join(special_char);\n      value_paths.set(value, seen_path);\n    } // Replace the value with the path\n\n\n    new_value = seen_path; // See if the new path is shorter\n\n    len = 1;\n\n    for (i = 0; i < path.length; i++) {\n      len += 1 + path[i].length;\n    }\n\n    len += key.length;\n\n    if (len < seen_path.length) {\n      temp = seen_path;\n      seen_path = path.slice(0); // The key of the current value still needs to be added\n\n      seen_path.push(key); // First iterate over the pieces and escape them\n\n      for (i = 0; i < seen_path.length; i++) {\n        if (seen_path[i].indexOf(special_char) > -1) {\n          seen_path[i] = seen_path[i].replace(special_char_rg, safe_special_char);\n        }\n      }\n\n      seen_path = special_char + seen_path.join(special_char);\n      value_paths.set(value, seen_path); // This entry still has to refer to the longer path,\n      // otherwise it'll refer to itself\n\n      seen_path = temp;\n    }\n\n    value = new_value;\n    return value;\n  }\n\n  if (!flags.is_root && !is_wrap) {\n    path.push(key);\n  } else {\n    flags.is_root = false;\n  } // Make a copy of the current path array\n\n\n  value_paths.set(value, path.slice(0));\n\n  if (driers[class_name] != null) {\n    value = driers[class_name].fnc(holder, key, value);\n    value = {\n      dry: class_name,\n      value: value\n    };\n\n    if (driers[class_name].options.add_path !== false) {\n      value.drypath = path.slice(0);\n    }\n\n    replaced = {\n      '': value\n    };\n  } else if (class_name === 'RegExp' && value.constructor == RegExp) {\n    value = {\n      dry: 'regexp',\n      value: value.toString()\n    };\n    replaced = {\n      '': value\n    };\n  } else if (class_name === 'Date' && value.constructor == Date) {\n    // Get numeric value first\n    temp = value.valueOf();\n\n    if (isNaN(temp)) {\n      temp = 'invalid';\n    } else {\n      temp = value.toISOString();\n    }\n\n    value = {\n      dry: 'date',\n      value: temp\n    };\n    replaced = {\n      '': value\n    };\n  } else if (typeof value.toDry === 'function') {\n    temp = value;\n    value = value.toDry(); // If no path was supplied in the toDry,\n    // get some more class information\n\n    if (!value.path) {\n      if (temp.constructor) {\n        if (!value.namespace && temp.constructor.namespace) {\n          value.namespace = temp.constructor.namespace;\n        }\n\n        if (!value.dry_class) {\n          value.dry_class = temp.constructor.name;\n        }\n      }\n    }\n\n    value.dry = 'toDry';\n    value.drypath = path.slice(0);\n    replaced = {\n      '': value\n    };\n  } else if (typeof value.toJSON === 'function') {\n    value = value.toJSON();\n    replaced = {\n      '': value\n    };\n  } else {\n    is_array = Array.isArray(value);\n  }\n\n  if (replaced) {\n    // Push the replaced object on the chain\n    chain.push(replaced); // Jsonify the replaced object\n\n    value = dryReplacer(replaced, false, replaced['']); // At least one part of the path & chain will have\n    // to be popped off. This is needed for toJSON calls\n    // that return primitive values\n\n    temp = chain.pop(); // Don't pop off anything from the path if the last item\n    // from the chain was a wrapper for an object,\n    // because then it'll already be popped of\n\n    if (!(temp && temp.__is_wrap && temp.__is_object)) {\n      path.pop();\n    } // Break out of the switch\n\n\n    return value;\n  } // Push this object on the chain\n\n\n  chain.push(value);\n\n  if (is_array) {\n    new_value = [];\n\n    for (i = 0; i < value.length; i++) {\n      new_value[i] = dryReplacer(value, String(i), value[i]);\n    }\n  } else {\n    new_value = recurseGeneralObject(dryReplacer, value);\n  }\n\n  value = new_value;\n  return value;\n}\n/**\n * Recursively replace the given regular object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.11\n * @version  1.0.11\n *\n * @param    {Function}   dryReplacer\n * @param    {Object}     value\n *\n * @return   {Object}\n */\n\n\nfunction recurseGeneralObject(dryReplacer, value) {\n  var new_value = {},\n      keys = Object.keys(value),\n      key,\n      i;\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    new_value[key] = dryReplacer(value, key, value[key]);\n  }\n\n  return new_value;\n}\n/**\n * Generate reviver function\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.0\n * @version  1.0.2\n *\n * @param    {Function}   reviver\n * @param    {Map}        undry_paths\n *\n * @return   {Function}\n */\n\n\nfunction generateReviver(reviver, undry_paths) {\n  return function dryReviver(key, value) {\n    var val_type = typeof value,\n        constructor,\n        temp;\n\n    if (val_type === 'string') {\n      if (value[0] === special_char) {\n        // This is actually a path that needs to be replaced.\n        // Put in a String object for now\n        return new String(value.slice(1));\n      } else if (value[0] == '\\\\' && value[1] == 'x' && value[2] == '7' && value[3] == 'e') {\n        value = special_char + value.slice(4);\n      }\n    } else if (value && value.dry != null) {\n      switch (value.dry) {\n        case 'date':\n          if (value.value) {\n            return new Date(value.value);\n          }\n\n          break;\n\n        case 'regexp':\n          if (value.value) {\n            return RegExp.apply(undefined, get_regex.exec(value.value).slice(1));\n          }\n\n          break;\n\n        case '+Infinity':\n          return Infinity;\n\n        case '-Infinity':\n          return -Infinity;\n\n        case 'toDry':\n          constructor = findClass(value); // Undry this element, but don't put it in the parsed object yet\n\n          if (constructor && typeof constructor.unDry === 'function') {\n            value.unDryConstructor = constructor;\n          } else {\n            value.undried = value.value;\n          }\n\n          if (value.drypath) {\n            undry_paths.set(value.drypath.join(special_char), value);\n          } else {\n            return value.undried;\n          }\n\n          break;\n\n        default:\n          if (typeof value.value !== 'undefined') {\n            if (undriers[value.dry]) {\n              value.unDryFunction = undriers[value.dry].fnc;\n\n              if (!value.drypath) {\n                // No path given? Then do the undrying right now\n                value.undried = value.unDryFunction(this, key, value.value);\n              }\n            } else {\n              value.undried = value.value;\n            }\n\n            if (value.drypath) {\n              undry_paths.set(value.drypath.join(special_char), value);\n            } else {\n              return value.undried;\n            }\n          }\n\n      }\n    }\n\n    if (reviver == null) {\n      return value;\n    }\n\n    return reviver.call(this, key, value);\n  };\n}\n\n;\n/**\n * Deep clone an object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.10\n *\n * @param    {Object}   obj\n * @param    {String}   custom_method   Custom method to use if available\n * @param    {Array}    extra_args      Extra arguments for the custom method\n * @param    {WeakMap}  wm\n *\n * @return   {Object}\n */\n\nfunction clone(obj, custom_method, extra_args, wm) {\n  if (custom_method instanceof WeakMap) {\n    wm = custom_method;\n    custom_method = null;\n  } else if (extra_args instanceof WeakMap) {\n    wm = extra_args;\n    extra_args = null;\n  }\n\n  if (!wm) {\n    wm = new WeakMap();\n    wm.source = obj;\n    wm.custom_method = custom_method;\n    wm.extra_args = extra_args;\n  } else if (wm.has(obj)) {\n    return wm.get(obj);\n  }\n\n  if (custom_method) {\n    extra_args = [wm].concat(extra_args);\n  }\n\n  return real_clone({\n    '_': obj\n  }, custom_method, extra_args, wm)['_'];\n}\n/**\n * Deep clone an object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.10\n *\n * @param    {Object}   obj\n * @param    {String}   custom_method   Custom method to use if available\n * @param    {Array}    extra_args      Extra arguments for the custom method\n * @param    {WeakMap}  wm\n *\n * @return   {Object}\n */\n\n\nfunction real_clone(obj, custom_method, extra_args, wm) {\n  var entry_type, name_type, target, entry, split, keys, temp, key, len, i;\n\n  if (Array.isArray(obj)) {\n    target = [];\n  } else {\n    target = {};\n  }\n\n  keys = Object.keys(obj);\n  len = keys.length; // Remember the root object and its clone\n\n  wm.set(obj, target);\n\n  for (i = 0; i < len; i++) {\n    key = keys[i];\n    entry = obj[key];\n    entry_type = typeof entry;\n\n    if (entry && (entry_type == 'object' || entry_type == 'function')) {\n      if (entry_type == 'function' && !driers.Function) {\n        continue;\n      } // If this has been cloned before, use that\n\n\n      if (wm.has(entry)) {\n        target[key] = wm.get(entry);\n        continue;\n      }\n\n      if (entry.constructor) {\n        name_type = entry.constructor.name;\n\n        if (custom_method && entry[custom_method]) {\n          target[key] = entry[custom_method].apply(entry, extra_args);\n        } else if (driers[name_type] != null) {\n          // Look for a registered drier function\n          temp = driers[name_type].fnc(obj, key, entry);\n\n          if (undriers[name_type]) {\n            target[key] = undriers[name_type].fnc(target, key, temp);\n          } else {\n            target[key] = temp;\n          }\n        } else if (entry.dryClone) {\n          // Look for dryClone after\n          target[key] = entry.dryClone(wm, custom_method);\n        } else if (entry.toDry) {\n          // Perform the toDry function\n          temp = entry.toDry(); // Clone the value,\n          // because returned objects aren't necesarilly cloned yet\n\n          temp = real_clone(temp, custom_method, extra_args, wm).value; // Perform the undry function\n\n          if (entry.constructor.unDry) {\n            target[key] = entry.constructor.unDry(temp, custom_method || true);\n          } else {\n            // If there is no undry function, the clone will be a simple object\n            target[key] = temp;\n          }\n        } else if (name_type == 'Date') {\n          target[key] = new Date(entry);\n        } else if (name_type == 'RegExp') {\n          temp = entry.toString();\n          split = temp.match(/^\\/(.*?)\\/([gim]*)$/);\n\n          if (split) {\n            target[key] = RegExp(split[1], split[2]);\n          } else {\n            target[key] = RegExp(temp);\n          }\n        } else if (typeof entry.clone == 'function') {\n          // If it supplies a clone method, use that\n          target[key] = entry.clone();\n        } else if (entry.toJSON) {\n          temp = entry.toJSON();\n\n          if (temp && typeof temp == 'object') {\n            temp = real_clone(temp, custom_method, extra_args, wm);\n          }\n\n          target[key] = temp;\n        } else {\n          target[key] = real_clone(entry, custom_method, extra_args, wm);\n        }\n      } else {\n        target[key] = real_clone(entry, custom_method, extra_args, wm);\n      } // Remember this clone for later\n\n\n      wm.set(entry, target[key]);\n    } else {\n      target[key] = entry;\n    }\n  }\n\n  return target;\n}\n/**\n * Register a drier\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.0\n *\n * @param    {Function|String}   constructor   What constructor to listen to\n * @param    {Function} fnc\n * @param    {Object}   options\n */\n\n\nfunction registerDrier(constructor, fnc, options) {\n  var path;\n\n  if (typeof constructor == 'function') {\n    path = constructor.name;\n  } else {\n    path = constructor;\n  }\n\n  driers[path] = {\n    fnc: fnc,\n    options: options || {}\n  };\n}\n/**\n * Register an undrier\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.0\n *\n * @param    {Function|String}   constructor   What constructor to listen to\n * @param    {Function} fnc\n * @param    {Object}   options\n */\n\n\nfunction registerUndrier(constructor, fnc, options) {\n  var path;\n\n  if (typeof constructor == 'function') {\n    path = constructor.name;\n  } else {\n    path = constructor;\n  }\n\n  undriers[path] = {\n    fnc: fnc,\n    options: options || {}\n  };\n}\n/**\n * Register a class that can be serialized/revived\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.5\n *\n * @param    {String}            name          The optional name of the class\n * @param    {Function|String}   constructor   What constructor to listen to\n */\n\n\nfunction registerClass(name, constructor) {\n  var context = exports.Classes;\n\n  if (typeof name == 'function') {\n    constructor = name;\n    name = constructor.name;\n  }\n\n  if (constructor.namespace) {\n    context = fromPath(exports.Classes, constructor.namespace);\n\n    if (!context) {\n      context = {};\n      setPath(exports.Classes, constructor.namespace.split('.'), context);\n    }\n  }\n\n  context[name] = constructor;\n}\n/**\n * Find a class\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.9\n *\n * @param    {String}   value   The name of the class\n */\n\n\nfunction findClass(value) {\n  var constructor, ns; // Return nothing for falsy values\n\n  if (!value) {\n    return null;\n  } // Look for a regular class when it's just a string\n\n\n  if (typeof value == 'string') {\n    if (exports.Classes[value]) {\n      return exports.Classes[value];\n    }\n\n    return null;\n  }\n\n  if (value.path) {\n    return fromPath(exports.Classes, value.path);\n  } else {\n    if (value.namespace) {\n      ns = fromPath(exports.Classes, value.namespace);\n    } else {\n      ns = exports.Classes;\n    }\n\n    if (value.dry_class) {\n      constructor = fromPath(ns, value.dry_class);\n    } else if (value.name) {\n      constructor = ns[value.name];\n    }\n\n    if (!constructor && ns) {\n      if (ns.main_class) {\n        ns = ns.main_class;\n      }\n\n      if (ns && typeof ns.getClassForUndry == 'function') {\n        constructor = ns.getClassForUndry(value.dry_class || value.name);\n      }\n    }\n  }\n\n  if (!constructor) {\n    console.log('Could not find constructor for', value);\n  }\n\n  return constructor;\n}\n/**\n * Regenerate an array\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.4\n * @version  1.0.8\n *\n * @return   {Array}\n */\n\n\nfunction regenerateArray(root, holder, current, seen, retrieve, undry_paths, old, current_path) {\n  var length = current.length,\n      temp,\n      i;\n\n  for (i = 0; i < length; i++) {\n    // Only regenerate if it's not yet seen\n    if (!seen.get(current[i])) {\n      temp = current_path.slice(0);\n      temp.push(i);\n      current[i] = regenerate(root, current, current[i], seen, retrieve, undry_paths, old, temp);\n    }\n  }\n\n  return current;\n}\n\n;\n/**\n * Regenerate an object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.4\n * @version  1.0.11\n *\n * @return   {Object}\n */\n\nfunction regenerateObject(root, holder, current, seen, retrieve, undry_paths, old, current_path) {\n  var path, temp, key;\n\n  for (key in current) {\n    if (current.hasOwnProperty(key)) {\n      // Only regenerate if it's not already seen\n      if (!seen.get(current[key])) {\n        path = current_path.slice(0);\n        path.push(key);\n        temp = regenerate(root, current, current[key], seen, retrieve, undry_paths, old, path); // @TODO: Values returned by `unDry` methods also get regenerated,\n        // even though these could contain properties coming from somewhere else,\n        // like live HTMLCollections. Assigning anything to that will throw an error.\n        // This is a workaround to that proble: if the value is exactly the same,\n        // it's not needed to assign it again, so it won't throw an error,\n        // but it's not an ideal solution.\n\n        if (temp !== current[key]) {\n          current[key] = temp;\n        }\n      }\n    }\n  }\n\n  return current;\n}\n\n;\n/**\n * Regenerate a value\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.4\n * @version  1.0.8\n *\n * @return   {Mixed}\n */\n\nfunction regenerate(root, holder, current, seen, retrieve, undry_paths, old, current_path) {\n  var temp;\n\n  if (current && typeof current == 'object') {\n    // Remember this object has been regenerated already\n    seen.set(current, true);\n\n    if (current instanceof Array) {\n      return regenerateArray(root, holder, current, seen, retrieve, undry_paths, old, current_path);\n    }\n\n    if (current instanceof String) {\n      if (current.length > -1) {\n        current = current.toString();\n\n        if (temp = undry_paths.get(current)) {\n          if (typeof temp.undried != 'undefined') {\n            return temp.undried;\n          }\n\n          if (!holder) {\n            throw new Error('Unable to resolve recursive reference');\n          }\n\n          undry_paths.extra_pass.push([holder, temp, current_path]);\n          return temp;\n        }\n\n        if (retrieve.hasOwnProperty(current)) {\n          temp = retrieve[current];\n        } else {\n          temp = retrieve[current] = retrieveFromPath(root, current.split(special_char));\n\n          if (typeof temp == 'undefined') {\n            temp = retrieve[current] = getFromOld(old, current.split(special_char));\n          }\n        } // Because we always regenerate parsed objects first\n        // (JSON-dry parsing goes from string » object » regenerated object)\n        // keys of regular objects can appear out-of-order, so we need to parse them\n\n\n        if (temp && temp instanceof String) {\n          // Unset the String as a valid result\n          retrieve[current] = null; // Regenerate the string again\n          // (We have to create a new instance, because it's already been \"seen\")\n\n          temp = retrieve[current] = regenerate(root, holder, new String(temp), seen, retrieve, undry_paths, old, current_path);\n        }\n\n        return temp;\n      } else {\n        return root;\n      }\n    }\n\n    return regenerateObject(root, holder, current, seen, retrieve, undry_paths, old, current_path);\n  }\n\n  return current;\n}\n\n;\n/**\n * Find path in an \"old\" object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.10\n * @version  1.0.10\n *\n * @param    {Object}   old      The object to look in\n * @param    {Array}    pieces   The path to look for\n *\n * @return   {Mixed}\n */\n\nfunction getFromOld(old, pieces) {\n  var length = pieces.length,\n      result,\n      path,\n      rest,\n      i;\n\n  for (i = 0; i < length; i++) {\n    path = pieces.slice(0, length - i).join('.');\n    result = old[path];\n\n    if (typeof result != 'undefined') {\n      if (i == 0) {\n        return result;\n      }\n\n      rest = pieces.slice(pieces.length - i);\n      result = retrieveFromPath(result, rest);\n\n      if (typeof result != 'undefined') {\n        return result;\n      }\n    }\n  }\n}\n/**\n * Retrieve from path.\n * Set the given value, but only if the containing object exists.\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.4\n * @version  1.0.10\n *\n * @param    {Object}   current   The object to look in\n * @param    {Array}    keys      The path to look for\n * @param    {Mixed}    value     Optional value to set\n *\n * @return   {Mixed}\n */\n\n\nfunction retrieveFromPath(current, keys) {\n  var length = keys.length,\n      prev,\n      key,\n      i; // Keys [''] always means the root\n\n  if (length == 1 && keys[0] === '') {\n    return current;\n  }\n\n  for (i = 0; i < length; i++) {\n    key = keys[i]; // Normalize the key\n\n    if (typeof key == 'number') {// Allow\n    } else if (key.indexOf(safe_special_char) > -1) {\n      key = key.replace(safe_special_char_rg, special_char);\n    }\n\n    prev = current;\n\n    if (current) {\n      if (current.hasOwnProperty(key)) {\n        current = current[key];\n      } else {\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  return current;\n}\n/**\n * Extract something from an object by the path\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.1.0\n * @version  1.0.0\n *\n * @param    {Object}    obj\n * @param    {String}    path\n *\n * @return   {Mixed}\n */\n\n\nfunction fromPath(obj, path) {\n  var pieces, here, len, i;\n\n  if (typeof path == 'string') {\n    pieces = path.split('.');\n  } else {\n    pieces = path;\n  }\n\n  here = obj; // Go over every piece in the path\n\n  for (i = 0; i < pieces.length; i++) {\n    if (here != null) {\n      if (here.hasOwnProperty(pieces[i])) {\n        here = here[pieces[i]];\n      } else {\n        return null;\n      }\n    } else {\n      break;\n    }\n  }\n\n  return here;\n}\n/**\n * Set something on the given path\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.2\n *\n * @param    {Object}    obj\n * @param    {Array}     path\n * @param    {Boolean}   force   If a piece of the path doesn't exist, create it\n *\n * @return   {Mixed}\n */\n\n\nfunction setPath(obj, keys, value, force) {\n  var here, i;\n  here = obj;\n\n  for (i = 0; i < keys.length - 1; i++) {\n    if (here != null) {\n      if (here.hasOwnProperty(keys[i])) {\n        here = here[keys[i]];\n      } else {\n        if (force && here[keys[i]] == null) {\n          here[keys[i]] = {};\n          here = here[keys[i]];\n          continue;\n        }\n\n        return null;\n      }\n    }\n  }\n\n  here[keys[keys.length - 1]] = value;\n}\n/**\n * Convert an object to a DRY object, ready for stringifying\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.0\n *\n * @param    {Object}   value\n * @param    {Function} replacer\n *\n * @return   {Object}\n */\n\n\nfunction toDryObject(value, replacer) {\n  var root = {\n    '': value\n  };\n  return createDryReplacer(root, replacer)(root, '', value);\n}\n/**\n * Convert directly to a string\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.0\n *\n * @param    {Object}   value\n * @param    {Function} replacer\n *\n * @return   {Object}\n */\n\n\nfunction stringify(value, replacer, space) {\n  return JSON.stringify(toDryObject(value, replacer), null, space);\n}\n/**\n * Map an object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    0.4.2\n * @version  1.0.0\n *\n * @param    {Object}     obj     The object to walk over\n * @param    {Function}   fnc     The function to perform on every entry\n * @param    {Object}     result  The object to add to\n *\n * @return   {Object}\n */\n\n\nfunction walk(obj, fnc, result, seen) {\n  var is_root, keys, key, ret, i;\n\n  if (!seen) {\n    seen = new WeakMap();\n  }\n\n  seen.set(obj, true);\n\n  if (!result) {\n    is_root = true;\n\n    if (Array.isArray(obj)) {\n      result = [];\n    } else {\n      result = {};\n    }\n  }\n\n  keys = Object.keys(obj);\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n\n    if (typeof obj[key] == 'object' && obj[key] != null) {\n      if (!seen.get(obj[key])) {\n        if (Array.isArray(obj[key])) {\n          result[key] = walk(obj[key], fnc, [], seen);\n        } else {\n          result[key] = walk(obj[key], fnc, {}, seen);\n        }\n      }\n\n      result[key] = fnc(key, result[key], result);\n    } else {\n      // Fire the function\n      result[key] = fnc(key, obj[key], obj);\n    }\n  }\n\n  if (is_root) {\n    result = fnc('', result);\n  }\n\n  return result;\n}\n/**\n * Convert from a dried object\n *\n * @author   Jelle De Loecker   <jelle@develry.be>\n * @since    1.0.0\n * @version  1.0.11\n *\n * @param    {Object}   value\n *\n * @return   {Object}\n */\n\n\nfunction parse(object, reviver) {\n  var undry_paths = new Map(),\n      retrieve = {},\n      reviver,\n      result,\n      holder,\n      entry,\n      temp,\n      seen,\n      path,\n      key,\n      old = {},\n      i; // Create the reviver function\n\n  reviver = generateReviver(reviver, undry_paths);\n\n  if (typeof object == 'string') {\n    object = JSON.parse(object);\n  }\n\n  if (!object || typeof object != 'object') {\n    return object;\n  }\n\n  result = walk(object, reviver);\n\n  if (result == null) {\n    return result;\n  } // To remember which objects have already been revived\n\n\n  seen = new WeakMap(); // Maybe paths need another round of undrying\n\n  undry_paths.extra_pass = []; // Iterate over all the values that require some kind of function to be revived\n\n  undry_paths.forEach(function eachEntry(entry, path) {\n    var path_array = entry.drypath,\n        path_string = path_array.join('.'); // Regenerate this replacement wrapper first\n\n    regenerate(result, null, entry, seen, retrieve, undry_paths, old, path_array.slice(0));\n\n    if (entry.unDryConstructor) {\n      entry.undried = entry.unDryConstructor.unDry(entry.value, false);\n    } else if (entry.unDryFunction) {\n      entry.undried = entry.unDryFunction(entry, null, entry.value);\n    } else {\n      entry.undried = entry.value;\n    } // Remember the old wrapper entry, some other references\n    // may still point to it's children\n\n\n    old[path_string] = entry;\n\n    if (entry.drypath && entry.drypath.length) {\n      setPath(result, entry.drypath, entry.undried);\n    }\n  });\n\n  for (i = 0; i < undry_paths.extra_pass.length; i++) {\n    entry = undry_paths.extra_pass[i];\n    holder = entry[0];\n    temp = entry[1];\n    path = entry[2];\n\n    for (key in holder) {\n      if (holder[key] == temp) {\n        holder[key] = temp.undried;\n        break;\n      }\n    }\n\n    path.pop(); // Annoying workaround for some circular references\n\n    if (path.length && path[path.length - 1] == 'value') {\n      path.pop();\n    }\n\n    if (path.length) {\n      // Get the other holder\n      holder = retrieveFromPath(result, path); // If the holder object was not found in the result,\n      // it was probably a child of ANOTHER holder that has already been undried & replaces\n      // Just get the value from the object containing old references\n\n      if (!holder) {\n        holder = getFromOld(old, path);\n      }\n\n      for (key in holder) {\n        if (holder[key] == temp) {\n          holder[key] = temp.undried;\n          break;\n        }\n      }\n    }\n  } // Only now we can resolve paths\n\n\n  result = regenerate(result, result, result, seen, retrieve, undry_paths, old, []);\n\n  if (result.undried != null && result.dry) {\n    return result.undried;\n  }\n\n  return result;\n}\n\nexports.stringify = stringify;\nexports.toObject = toDryObject;\nexports.parse = parse;\nexports.clone = clone;\nexports.Classes = {};\nexports.registerClass = registerClass;\nexports.registerUndrier = registerUndrier;\nexports.registerDrier = registerDrier;\nexports.findClass = findClass;\nexports.walk = walk;","var v1 = require('./v1');\n\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nmodule.exports = uuid;"],"sourceRoot":""}